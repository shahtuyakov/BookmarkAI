/* tslint:disable */
/* eslint-disable */
/**
 * BookmarkAI API
 * API for managing bookmarks across multiple platforms.  ## ADR-012 Compliance  This API follows the BookmarkAI API Style Guide (ADR-012): - All responses wrapped in standard envelope format - Consistent error taxonomy with structured details - Request ID tracking via X-Request-ID header - Cursor-based pagination for feeds - Idempotency key support for mutations  **Status**: âœ… Fully implemented and tested (2025-06-09)  ## Response Format  All successful responses follow this structure: ```json {   \"success\": true,   \"data\": <response_data>,   \"meta\": {     \"requestId\": \"uuid\",     \"version\": \"1.0.0\",     \"deprecation\": \"optional\"   } } ```  All error responses follow this structure: ```json {   \"success\": false,   \"error\": {     \"code\": \"ERROR_CATEGORY_SPECIFIC\",     \"message\": \"Human readable message\",     \"details\": { \"optional\": \"context\" },     \"timestamp\": \"2025-06-09T14:30:00.000Z\",     \"traceId\": \"uuid\"   } } ``` 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@bookmarkai.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * Hierarchical error code
     * @type {string}
     * @memberof ApiError
     */
    'code': string;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof ApiError
     */
    'message': string;
    /**
     * 
     * @type {ApiErrorDetails}
     * @memberof ApiError
     */
    'details'?: ApiErrorDetails;
    /**
     * When the error occurred
     * @type {string}
     * @memberof ApiError
     */
    'timestamp': string;
    /**
     * Trace ID for debugging
     * @type {string}
     * @memberof ApiError
     */
    'traceId': string;
}
/**
 * Additional error context
 * @export
 * @interface ApiErrorDetails
 */
export interface ApiErrorDetails {
    [key: string]: any;

    /**
     * Field that caused validation error
     * @type {string}
     * @memberof ApiErrorDetails
     */
    'field'?: string;
    /**
     * Validation rule that was violated
     * @type {string}
     * @memberof ApiErrorDetails
     */
    'constraint'?: string;
    /**
     * How to fix the error
     * @type {string}
     * @memberof ApiErrorDetails
     */
    'suggestion'?: string;
}
/**
 * 
 * @export
 * @interface AsyncOperationResponse
 */
export interface AsyncOperationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof AsyncOperationResponse
     */
    'success': boolean;
    /**
     * 
     * @type {AsyncOperationResponseAllOfData}
     * @memberof AsyncOperationResponse
     */
    'data': AsyncOperationResponseAllOfData;
    /**
     * 
     * @type {ResponseMeta}
     * @memberof AsyncOperationResponse
     */
    'meta'?: ResponseMeta;
}
/**
 * 
 * @export
 * @interface AsyncOperationResponseAllOfData
 */
export interface AsyncOperationResponseAllOfData {
    /**
     * Operation identifier
     * @type {string}
     * @memberof AsyncOperationResponseAllOfData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AsyncOperationResponseAllOfData
     */
    'status': AsyncOperationResponseAllOfDataStatusEnum;
    /**
     * URL to check operation status
     * @type {string}
     * @memberof AsyncOperationResponseAllOfData
     */
    'statusUrl': string;
    /**
     * 
     * @type {AsyncOperationResponseAllOfDataProgress}
     * @memberof AsyncOperationResponseAllOfData
     */
    'progress'?: AsyncOperationResponseAllOfDataProgress | null;
    /**
     * Operation result (when status is \'completed\')
     * @type {{ [key: string]: any; }}
     * @memberof AsyncOperationResponseAllOfData
     */
    'result'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {AsyncOperationResponseAllOfDataError}
     * @memberof AsyncOperationResponseAllOfData
     */
    'error'?: AsyncOperationResponseAllOfDataError;
}

export const AsyncOperationResponseAllOfDataStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type AsyncOperationResponseAllOfDataStatusEnum = typeof AsyncOperationResponseAllOfDataStatusEnum[keyof typeof AsyncOperationResponseAllOfDataStatusEnum];

/**
 * 
 * @export
 * @interface AsyncOperationResponseAllOfDataError
 */
export interface AsyncOperationResponseAllOfDataError {
    /**
     * Hierarchical error code
     * @type {string}
     * @memberof AsyncOperationResponseAllOfDataError
     */
    'code': string;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof AsyncOperationResponseAllOfDataError
     */
    'message': string;
    /**
     * 
     * @type {ApiErrorDetails}
     * @memberof AsyncOperationResponseAllOfDataError
     */
    'details'?: ApiErrorDetails;
    /**
     * When the error occurred
     * @type {string}
     * @memberof AsyncOperationResponseAllOfDataError
     */
    'timestamp': string;
    /**
     * Trace ID for debugging
     * @type {string}
     * @memberof AsyncOperationResponseAllOfDataError
     */
    'traceId': string;
}
/**
 * 
 * @export
 * @interface AsyncOperationResponseAllOfDataProgress
 */
export interface AsyncOperationResponseAllOfDataProgress {
    /**
     * 
     * @type {number}
     * @memberof AsyncOperationResponseAllOfDataProgress
     */
    'current'?: number;
    /**
     * 
     * @type {number}
     * @memberof AsyncOperationResponseAllOfDataProgress
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface CreateShareRequest
 */
export interface CreateShareRequest {
    /**
     * URL from supported platform
     * @type {string}
     * @memberof CreateShareRequest
     */
    'url': string;
    /**
     * Optional custom title
     * @type {string}
     * @memberof CreateShareRequest
     */
    'title'?: string;
    /**
     * Optional notes
     * @type {string}
     * @memberof CreateShareRequest
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface CreateSharesBatchRequest
 */
export interface CreateSharesBatchRequest {
    /**
     * 
     * @type {Array<CreateSharesBatchRequestOperationsInner>}
     * @memberof CreateSharesBatchRequest
     */
    'operations': Array<CreateSharesBatchRequestOperationsInner>;
}
/**
 * 
 * @export
 * @interface CreateSharesBatchRequestOperationsInner
 */
export interface CreateSharesBatchRequestOperationsInner {
    /**
     * 
     * @type {string}
     * @memberof CreateSharesBatchRequestOperationsInner
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSharesBatchRequestOperationsInner
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSharesBatchRequestOperationsInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateSharesBatchRequestOperationsInner
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ErrorResponse
     */
    'success': boolean;
    /**
     * 
     * @type {ApiError}
     * @memberof ErrorResponse
     */
    'error': ApiError;
}
/**
 * 
 * @export
 * @interface FeaturesResponse
 */
export interface FeaturesResponse {
    /**
     * 
     * @type {boolean}
     * @memberof FeaturesResponse
     */
    'success': boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FeaturesResponse
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {ResponseMeta}
     * @memberof FeaturesResponse
     */
    'meta'?: ResponseMeta;
}
/**
 * 
 * @export
 * @interface HealthResponse
 */
export interface HealthResponse {
    /**
     * 
     * @type {boolean}
     * @memberof HealthResponse
     */
    'success': boolean;
    /**
     * 
     * @type {HealthResponseAllOfData}
     * @memberof HealthResponse
     */
    'data': HealthResponseAllOfData;
    /**
     * 
     * @type {ResponseMeta}
     * @memberof HealthResponse
     */
    'meta'?: ResponseMeta;
}
/**
 * 
 * @export
 * @interface HealthResponseAllOfData
 */
export interface HealthResponseAllOfData {
    /**
     * 
     * @type {string}
     * @memberof HealthResponseAllOfData
     */
    'status': HealthResponseAllOfDataStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof HealthResponseAllOfData
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof HealthResponseAllOfData
     */
    'version'?: string;
    /**
     * 
     * @type {{ [key: string]: HealthResponseAllOfDataChecks; }}
     * @memberof HealthResponseAllOfData
     */
    'checks'?: { [key: string]: HealthResponseAllOfDataChecks; };
}

export const HealthResponseAllOfDataStatusEnum = {
    Healthy: 'healthy',
    Unhealthy: 'unhealthy'
} as const;

export type HealthResponseAllOfDataStatusEnum = typeof HealthResponseAllOfDataStatusEnum[keyof typeof HealthResponseAllOfDataStatusEnum];

/**
 * 
 * @export
 * @interface HealthResponseAllOfDataChecks
 */
export interface HealthResponseAllOfDataChecks {
    /**
     * 
     * @type {string}
     * @memberof HealthResponseAllOfDataChecks
     */
    'status'?: HealthResponseAllOfDataChecksStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof HealthResponseAllOfDataChecks
     */
    'message'?: string;
}

export const HealthResponseAllOfDataChecksStatusEnum = {
    Up: 'up',
    Down: 'down'
} as const;

export type HealthResponseAllOfDataChecksStatusEnum = typeof HealthResponseAllOfDataChecksStatusEnum[keyof typeof HealthResponseAllOfDataChecksStatusEnum];

/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponse
     */
    'success': boolean;
    /**
     * 
     * @type {LoginResponseAllOfData}
     * @memberof LoginResponse
     */
    'data': LoginResponseAllOfData;
    /**
     * 
     * @type {ResponseMeta}
     * @memberof LoginResponse
     */
    'meta'?: ResponseMeta;
}
/**
 * 
 * @export
 * @interface LoginResponseAllOfData
 */
export interface LoginResponseAllOfData {
    /**
     * JWT access token
     * @type {string}
     * @memberof LoginResponseAllOfData
     */
    'accessToken': string;
    /**
     * Refresh token for getting new access tokens
     * @type {string}
     * @memberof LoginResponseAllOfData
     */
    'refreshToken': string;
    /**
     * 
     * @type {User}
     * @memberof LoginResponseAllOfData
     */
    'user': User;
}
/**
 * Detected platform from URL: - `tiktok`: TikTok videos - `reddit`: Reddit posts - `twitter`: Twitter posts - `x`: X (formerly Twitter) posts - `unknown`: Unsupported or undetected platform 
 * @export
 * @enum {string}
 */

export const Platform = {
    Tiktok: 'tiktok',
    Reddit: 'reddit',
    Twitter: 'twitter',
    X: 'x',
    Unknown: 'unknown'
} as const;

export type Platform = typeof Platform[keyof typeof Platform];


/**
 * 
 * @export
 * @interface RefreshTokenRequest
 */
export interface RefreshTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenRequest
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface ResponseMeta
 */
export interface ResponseMeta {
    /**
     * Request correlation ID
     * @type {string}
     * @memberof ResponseMeta
     */
    'requestId': string;
    /**
     * API version
     * @type {string}
     * @memberof ResponseMeta
     */
    'version'?: string;
    /**
     * Deprecation date (if applicable)
     * @type {string}
     * @memberof ResponseMeta
     */
    'deprecation'?: string;
}
/**
 * 
 * @export
 * @interface Share
 */
export interface Share {
    /**
     * 
     * @type {string}
     * @memberof Share
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Share
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Share
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Share
     */
    'notes'?: string | null;
    /**
     * 
     * @type {ShareStatus}
     * @memberof Share
     */
    'status': ShareStatus;
    /**
     * 
     * @type {Platform}
     * @memberof Share
     */
    'platform': Platform;
    /**
     * 
     * @type {string}
     * @memberof Share
     */
    'userId': string;
    /**
     * Platform-specific metadata (when processed)
     * @type {{ [key: string]: any; }}
     * @memberof Share
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof Share
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Share
     */
    'updatedAt': string;
    /**
     * When processing completed (if status is \'done\')
     * @type {string}
     * @memberof Share
     */
    'processedAt'?: string | null;
}


/**
 * 
 * @export
 * @interface ShareListResponse
 */
export interface ShareListResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ShareListResponse
     */
    'success': boolean;
    /**
     * 
     * @type {ShareListResponseAllOfData}
     * @memberof ShareListResponse
     */
    'data': ShareListResponseAllOfData;
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ShareListResponse
     */
    'meta'?: ResponseMeta;
}
/**
 * 
 * @export
 * @interface ShareListResponseAllOfData
 */
export interface ShareListResponseAllOfData {
    /**
     * 
     * @type {Array<Share>}
     * @memberof ShareListResponseAllOfData
     */
    'items': Array<Share>;
    /**
     * Cursor for next page (if hasMore is true)
     * @type {string}
     * @memberof ShareListResponseAllOfData
     */
    'cursor'?: string;
    /**
     * Whether more items are available
     * @type {boolean}
     * @memberof ShareListResponseAllOfData
     */
    'hasMore': boolean;
    /**
     * Number of items requested
     * @type {number}
     * @memberof ShareListResponseAllOfData
     */
    'limit': number;
    /**
     * Total count (only if efficiently countable)
     * @type {number}
     * @memberof ShareListResponseAllOfData
     */
    'total'?: number | null;
}
/**
 * 
 * @export
 * @interface ShareQueueEntry
 */
export interface ShareQueueEntry {
    /**
     * ULID format identifier
     * @type {string}
     * @memberof ShareQueueEntry
     */
    'id': string;
    /**
     * URL to be shared
     * @type {string}
     * @memberof ShareQueueEntry
     */
    'url': string;
    /**
     * ISO 8601 timestamp
     * @type {string}
     * @memberof ShareQueueEntry
     */
    'createdAt': string;
    /**
     * Processing status
     * @type {string}
     * @memberof ShareQueueEntry
     */
    'status': ShareQueueEntryStatusEnum;
    /**
     * Platform that created the share
     * @type {string}
     * @memberof ShareQueueEntry
     */
    'source': ShareQueueEntrySourceEnum;
    /**
     * 
     * @type {ShareQueueEntryMetadata}
     * @memberof ShareQueueEntry
     */
    'metadata'?: ShareQueueEntryMetadata | null;
}

export const ShareQueueEntryStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type ShareQueueEntryStatusEnum = typeof ShareQueueEntryStatusEnum[keyof typeof ShareQueueEntryStatusEnum];
export const ShareQueueEntrySourceEnum = {
    IosShareExtension: 'ios-share-extension',
    AndroidShareIntent: 'android-share-intent',
    Webextension: 'webextension',
    ReactNative: 'react-native'
} as const;

export type ShareQueueEntrySourceEnum = typeof ShareQueueEntrySourceEnum[keyof typeof ShareQueueEntrySourceEnum];

/**
 * 
 * @export
 * @interface ShareQueueEntryMetadata
 */
export interface ShareQueueEntryMetadata {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ShareQueueEntryMetadata
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShareQueueEntryMetadata
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ShareResponse
 */
export interface ShareResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ShareResponse
     */
    'success': boolean;
    /**
     * 
     * @type {Share}
     * @memberof ShareResponse
     */
    'data': Share;
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ShareResponse
     */
    'meta'?: ResponseMeta;
}
/**
 * Processing status: - `pending`: Queued for processing - `processing`: Currently being processed - `done`: Successfully processed - `failed`: Processing failed 
 * @export
 * @enum {string}
 */

export const ShareStatus = {
    Pending: 'pending',
    Processing: 'processing',
    Done: 'done',
    Failed: 'failed'
} as const;

export type ShareStatus = typeof ShareStatus[keyof typeof ShareStatus];


/**
 * 
 * @export
 * @interface SharesBatchResponse
 */
export interface SharesBatchResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SharesBatchResponse
     */
    'success': boolean;
    /**
     * 
     * @type {SharesBatchResponseAllOfData}
     * @memberof SharesBatchResponse
     */
    'data': SharesBatchResponseAllOfData;
    /**
     * 
     * @type {ResponseMeta}
     * @memberof SharesBatchResponse
     */
    'meta'?: ResponseMeta;
}
/**
 * 
 * @export
 * @interface SharesBatchResponseAllOfData
 */
export interface SharesBatchResponseAllOfData {
    /**
     * 
     * @type {Array<Share>}
     * @memberof SharesBatchResponseAllOfData
     */
    'succeeded': Array<Share>;
    /**
     * 
     * @type {Array<SharesBatchResponseAllOfDataFailed>}
     * @memberof SharesBatchResponseAllOfData
     */
    'failed': Array<SharesBatchResponseAllOfDataFailed>;
}
/**
 * 
 * @export
 * @interface SharesBatchResponseAllOfDataFailed
 */
export interface SharesBatchResponseAllOfDataFailed {
    /**
     * Index in original request array
     * @type {number}
     * @memberof SharesBatchResponseAllOfDataFailed
     */
    'index': number;
    /**
     * 
     * @type {ApiError}
     * @memberof SharesBatchResponseAllOfDataFailed
     */
    'error': ApiError;
    /**
     * 
     * @type {SharesBatchResponseAllOfDataItem}
     * @memberof SharesBatchResponseAllOfDataFailed
     */
    'item'?: SharesBatchResponseAllOfDataItem;
}
/**
 * Original request item that failed
 * @export
 * @interface SharesBatchResponseAllOfDataItem
 */
export interface SharesBatchResponseAllOfDataItem {
    /**
     * 
     * @type {string}
     * @memberof SharesBatchResponseAllOfDataItem
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof SharesBatchResponseAllOfDataItem
     */
    'idempotencyKey'?: string;
}
/**
 * 
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SuccessResponse
     */
    'success': boolean;
    /**
     * Response payload (varies by endpoint)
     * @type {object}
     * @memberof SuccessResponse
     */
    'data': object;
    /**
     * 
     * @type {ResponseMeta}
     * @memberof SuccessResponse
     */
    'meta'?: ResponseMeta;
}
/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TokenResponse
     */
    'success': boolean;
    /**
     * 
     * @type {TokenResponseAllOfData}
     * @memberof TokenResponse
     */
    'data': TokenResponseAllOfData;
    /**
     * 
     * @type {ResponseMeta}
     * @memberof TokenResponse
     */
    'meta'?: ResponseMeta;
}
/**
 * 
 * @export
 * @interface TokenResponseAllOfData
 */
export interface TokenResponseAllOfData {
    /**
     * 
     * @type {string}
     * @memberof TokenResponseAllOfData
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseAllOfData
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login user
         * @param {LoginRequest} loginRequest 
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, xRequestID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xRequestID != null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout user
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (xRequestID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xRequestID != null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshTokenRequest: RefreshTokenRequest, xRequestID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('refreshToken', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xRequestID != null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Login user
         * @param {LoginRequest} loginRequest 
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, xRequestID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, xRequestID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout user
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(xRequestID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(xRequestID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshTokenRequest: RefreshTokenRequest, xRequestID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenRequest, xRequestID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Login user
         * @param {LoginRequest} loginRequest 
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, xRequestID?: string, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.login(loginRequest, xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout user
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(xRequestID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logout(xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshTokenRequest: RefreshTokenRequest, xRequestID?: string, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.refreshToken(refreshTokenRequest, xRequestID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Login user
     * @param {LoginRequest} loginRequest 
     * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(loginRequest: LoginRequest, xRequestID?: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(loginRequest, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout user
     * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(xRequestID?: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh access token
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public refreshToken(refreshTokenRequest: RefreshTokenRequest, xRequestID?: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refreshToken(refreshTokenRequest, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SharesApi - axios parameter creator
 * @export
 */
export const SharesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new share
         * @param {string} idempotencyKey Unique key to prevent duplicate operations
         * @param {CreateShareRequest} createShareRequest 
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShare: async (idempotencyKey: string, createShareRequest: CreateShareRequest, xRequestID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idempotencyKey' is not null or undefined
            assertParamExists('createShare', 'idempotencyKey', idempotencyKey)
            // verify required parameter 'createShareRequest' is not null or undefined
            assertParamExists('createShare', 'createShareRequest', createShareRequest)
            const localVarPath = `/shares`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xRequestID != null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }
            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createShareRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create multiple shares in batch
         * @param {CreateSharesBatchRequest} createSharesBatchRequest 
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSharesBatch: async (createSharesBatchRequest: CreateSharesBatchRequest, xRequestID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSharesBatchRequest' is not null or undefined
            assertParamExists('createSharesBatch', 'createSharesBatchRequest', createSharesBatchRequest)
            const localVarPath = `/shares/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xRequestID != null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSharesBatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific share
         * @param {string} shareId Share UUID
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {Array<string>} [fields] Select specific fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShare: async (shareId: string, xRequestID?: string, fields?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareId' is not null or undefined
            assertParamExists('getShare', 'shareId', shareId)
            const localVarPath = `/shares/{shareId}`
                .replace(`{${"shareId"}}`, encodeURIComponent(String(shareId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }


    
            if (xRequestID != null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List user\'s shares
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {string} [cursor] Pagination cursor in format: &#x60;{timestamp}_{id}&#x60; Use the cursor from previous response to get next page 
         * @param {number} [limit] Number of items to return (1-100)
         * @param {ShareStatus} [status] Filter by processing status
         * @param {Array<Platform>} [platform] Filter by platform (comma-separated for OR)
         * @param {string} [createdAfter] Filter shares created after this date
         * @param {string} [createdBefore] Filter shares created before this date
         * @param {string} [sort] Sort fields (comma-separated). Prefix with &#x60;-&#x60; for descending order. Available fields: createdAt, platform, status 
         * @param {Array<string>} [fields] Select specific fields (comma-separated) to reduce response size. Available fields: id, url, platform, status, createdAt, updatedAt, title, notes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShares: async (xRequestID?: string, cursor?: string, limit?: number, status?: ShareStatus, platform?: Array<Platform>, createdAfter?: string, createdBefore?: string, sort?: string, fields?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shares`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (platform) {
                localVarQueryParameter['platform'] = platform.join(COLLECTION_FORMATS.csv);
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['createdAfter'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['createdBefore'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }


    
            if (xRequestID != null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharesApi - functional programming interface
 * @export
 */
export const SharesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SharesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new share
         * @param {string} idempotencyKey Unique key to prevent duplicate operations
         * @param {CreateShareRequest} createShareRequest 
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShare(idempotencyKey: string, createShareRequest: CreateShareRequest, xRequestID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShare(idempotencyKey, createShareRequest, xRequestID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SharesApi.createShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create multiple shares in batch
         * @param {CreateSharesBatchRequest} createSharesBatchRequest 
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSharesBatch(createSharesBatchRequest: CreateSharesBatchRequest, xRequestID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharesBatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSharesBatch(createSharesBatchRequest, xRequestID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SharesApi.createSharesBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific share
         * @param {string} shareId Share UUID
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {Array<string>} [fields] Select specific fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShare(shareId: string, xRequestID?: string, fields?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShare(shareId, xRequestID, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SharesApi.getShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List user\'s shares
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {string} [cursor] Pagination cursor in format: &#x60;{timestamp}_{id}&#x60; Use the cursor from previous response to get next page 
         * @param {number} [limit] Number of items to return (1-100)
         * @param {ShareStatus} [status] Filter by processing status
         * @param {Array<Platform>} [platform] Filter by platform (comma-separated for OR)
         * @param {string} [createdAfter] Filter shares created after this date
         * @param {string} [createdBefore] Filter shares created before this date
         * @param {string} [sort] Sort fields (comma-separated). Prefix with &#x60;-&#x60; for descending order. Available fields: createdAt, platform, status 
         * @param {Array<string>} [fields] Select specific fields (comma-separated) to reduce response size. Available fields: id, url, platform, status, createdAt, updatedAt, title, notes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShares(xRequestID?: string, cursor?: string, limit?: number, status?: ShareStatus, platform?: Array<Platform>, createdAfter?: string, createdBefore?: string, sort?: string, fields?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShares(xRequestID, cursor, limit, status, platform, createdAfter, createdBefore, sort, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SharesApi.listShares']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SharesApi - factory interface
 * @export
 */
export const SharesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SharesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new share
         * @param {string} idempotencyKey Unique key to prevent duplicate operations
         * @param {CreateShareRequest} createShareRequest 
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShare(idempotencyKey: string, createShareRequest: CreateShareRequest, xRequestID?: string, options?: RawAxiosRequestConfig): AxiosPromise<ShareResponse> {
            return localVarFp.createShare(idempotencyKey, createShareRequest, xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create multiple shares in batch
         * @param {CreateSharesBatchRequest} createSharesBatchRequest 
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSharesBatch(createSharesBatchRequest: CreateSharesBatchRequest, xRequestID?: string, options?: RawAxiosRequestConfig): AxiosPromise<SharesBatchResponse> {
            return localVarFp.createSharesBatch(createSharesBatchRequest, xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific share
         * @param {string} shareId Share UUID
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {Array<string>} [fields] Select specific fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShare(shareId: string, xRequestID?: string, fields?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<ShareResponse> {
            return localVarFp.getShare(shareId, xRequestID, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List user\'s shares
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {string} [cursor] Pagination cursor in format: &#x60;{timestamp}_{id}&#x60; Use the cursor from previous response to get next page 
         * @param {number} [limit] Number of items to return (1-100)
         * @param {ShareStatus} [status] Filter by processing status
         * @param {Array<Platform>} [platform] Filter by platform (comma-separated for OR)
         * @param {string} [createdAfter] Filter shares created after this date
         * @param {string} [createdBefore] Filter shares created before this date
         * @param {string} [sort] Sort fields (comma-separated). Prefix with &#x60;-&#x60; for descending order. Available fields: createdAt, platform, status 
         * @param {Array<string>} [fields] Select specific fields (comma-separated) to reduce response size. Available fields: id, url, platform, status, createdAt, updatedAt, title, notes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShares(xRequestID?: string, cursor?: string, limit?: number, status?: ShareStatus, platform?: Array<Platform>, createdAfter?: string, createdBefore?: string, sort?: string, fields?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<ShareListResponse> {
            return localVarFp.listShares(xRequestID, cursor, limit, status, platform, createdAfter, createdBefore, sort, fields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SharesApi - object-oriented interface
 * @export
 * @class SharesApi
 * @extends {BaseAPI}
 */
export class SharesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new share
     * @param {string} idempotencyKey Unique key to prevent duplicate operations
     * @param {CreateShareRequest} createShareRequest 
     * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharesApi
     */
    public createShare(idempotencyKey: string, createShareRequest: CreateShareRequest, xRequestID?: string, options?: RawAxiosRequestConfig) {
        return SharesApiFp(this.configuration).createShare(idempotencyKey, createShareRequest, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create multiple shares in batch
     * @param {CreateSharesBatchRequest} createSharesBatchRequest 
     * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharesApi
     */
    public createSharesBatch(createSharesBatchRequest: CreateSharesBatchRequest, xRequestID?: string, options?: RawAxiosRequestConfig) {
        return SharesApiFp(this.configuration).createSharesBatch(createSharesBatchRequest, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific share
     * @param {string} shareId Share UUID
     * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
     * @param {Array<string>} [fields] Select specific fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharesApi
     */
    public getShare(shareId: string, xRequestID?: string, fields?: Array<string>, options?: RawAxiosRequestConfig) {
        return SharesApiFp(this.configuration).getShare(shareId, xRequestID, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List user\'s shares
     * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
     * @param {string} [cursor] Pagination cursor in format: &#x60;{timestamp}_{id}&#x60; Use the cursor from previous response to get next page 
     * @param {number} [limit] Number of items to return (1-100)
     * @param {ShareStatus} [status] Filter by processing status
     * @param {Array<Platform>} [platform] Filter by platform (comma-separated for OR)
     * @param {string} [createdAfter] Filter shares created after this date
     * @param {string} [createdBefore] Filter shares created before this date
     * @param {string} [sort] Sort fields (comma-separated). Prefix with &#x60;-&#x60; for descending order. Available fields: createdAt, platform, status 
     * @param {Array<string>} [fields] Select specific fields (comma-separated) to reduce response size. Available fields: id, url, platform, status, createdAt, updatedAt, title, notes 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharesApi
     */
    public listShares(xRequestID?: string, cursor?: string, limit?: number, status?: ShareStatus, platform?: Array<Platform>, createdAfter?: string, createdBefore?: string, sort?: string, fields?: Array<string>, options?: RawAxiosRequestConfig) {
        return SharesApiFp(this.configuration).listShares(xRequestID, cursor, limit, status, platform, createdAfter, createdBefore, sort, fields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get feature flags
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatures: async (xRequestID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xRequestID != null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check async operation status
         * @param {string} operationId Operation ID returned from async endpoint
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationStatus: async (operationId: string, xRequestID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            assertParamExists('getOperationStatus', 'operationId', operationId)
            const localVarPath = `/operations/{operationId}`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xRequestID != null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Health check endpoint
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck: async (xRequestID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xRequestID != null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Server-sent events for real-time updates
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeToEvents: async (xRequestID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xRequestID != null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get feature flags
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatures(xRequestID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeaturesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatures(xRequestID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getFeatures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check async operation status
         * @param {string} operationId Operation ID returned from async endpoint
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOperationStatus(operationId: string, xRequestID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOperationStatus(operationId, xRequestID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getOperationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Health check endpoint
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck(xRequestID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(xRequestID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.healthCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Server-sent events for real-time updates
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeToEvents(xRequestID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeToEvents(xRequestID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.subscribeToEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * 
         * @summary Get feature flags
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatures(xRequestID?: string, options?: RawAxiosRequestConfig): AxiosPromise<FeaturesResponse> {
            return localVarFp.getFeatures(xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check async operation status
         * @param {string} operationId Operation ID returned from async endpoint
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationStatus(operationId: string, xRequestID?: string, options?: RawAxiosRequestConfig): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.getOperationStatus(operationId, xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Health check endpoint
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(xRequestID?: string, options?: RawAxiosRequestConfig): AxiosPromise<HealthResponse> {
            return localVarFp.healthCheck(xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Server-sent events for real-time updates
         * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeToEvents(xRequestID?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.subscribeToEvents(xRequestID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * 
     * @summary Get feature flags
     * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getFeatures(xRequestID?: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getFeatures(xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check async operation status
     * @param {string} operationId Operation ID returned from async endpoint
     * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getOperationStatus(operationId: string, xRequestID?: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getOperationStatus(operationId, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Health check endpoint
     * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public healthCheck(xRequestID?: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).healthCheck(xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Server-sent events for real-time updates
     * @param {string} [xRequestID] Optional request ID for tracing. If not provided, one will be generated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public subscribeToEvents(xRequestID?: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).subscribeToEvents(xRequestID, options).then((request) => request(this.axios, this.basePath));
    }
}



